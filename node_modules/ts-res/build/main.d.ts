import { ErrType, Result } from "./types";
/**
 * @method Ok - Returns a value with a type `T` of `Result<T, E>` signifying success of an operation. If the `T` type is `void` or `undefined` can be used without a value.
 * @returns `{ok: true, data: T}` result object.
 * @example
 * ```ts
 * function toNumber(str: string): Result<number, Error> {
 *   const parseResult = Number(str);
 *
 *   if (isNaN(parseResult)) {
 *     return Err(new Error(`Couldn't convert ${str} to number`));
 *   }
 *
 *   return Ok(parseResult);
 * }
 *
 * function testFileRead(path: string): Result<void, void> {
 *   const data = fs.readFile(path);
 *
 *   if (!data.length) {
 *     return Err();
 *   }
 *
 *   return Ok();
 * }
 * ```
 * */
export declare function Ok<T>(): Result<T | undefined, never>;
export declare function Ok<T>(data: T): Result<T, never>;
/**
 * @method Err - Returns a value with a type `E` of `Result<T, E>` signifying fail of an operation. If the `E` type is `void` or `undefined` can be used without a value.
 *
 * *Note:* `E` type is constrained by `undefined | void | string | Error`, custom error type that extends native `Error` also satisfies type boundaries
 * @returns `{ok: fale, error: E}` result object.
 * @example
 * ```ts
 * function toNumber(str: string): Result<number, Error> {
 *   const parseResult = Number(str);
 *
 *   if (isNaN(parseResult)) {
 *     return Err(new Error(`Couldn't convert ${str} to number`));
 *   }
 *
 *   return Ok(parseResult);
 * }
 *
 * function testFileRead(path: string): Result<void, void> {
 *   const data = fs.readFile(path);
 *
 *   if (!data.length) {
 *     return Err();
 *   }
 *
 *   return Ok();
 * }
 * ```
 * */
export declare function Err<E extends ErrType>(): Result<never, E | undefined>;
export declare function Err<E extends ErrType>(error: E): Result<never, E>;
