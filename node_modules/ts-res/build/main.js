"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Err = exports.Ok = void 0;
// --- Note ---
// `throw` is a reserved keyword
function throwErr(message) {
    if (!this.ok) {
        if (typeof this.error === "string" || typeof this.error === "undefined") {
            const defaultMessage = "There was an error! No specific error message was provided.";
            throw new Error(message || this.error || defaultMessage);
        }
        if (message) {
            this.error.message = message;
        }
        throw this.error;
    }
    return this.data;
}
// --- Note ---
// `else` is a reserved keyword
function elseDo(callback) {
    if (this.ok) {
        return this.data;
    }
    // TODO:
    // - Tackle the problem of callback return type not being enforced when using `void` | `undefined` as `T`
    // - In the same situation `or` works well
    return callback(this.error);
}
function or(orValue) {
    if (this.ok) {
        return this.data;
    }
    return orValue;
}
function and(callback) {
    if (this.ok) {
        callback(this.data);
    }
}
function Ok(data) {
    return { ok: true, data, throw: throwErr, else: elseDo, or, and };
}
exports.Ok = Ok;
function Err(error) {
    return { ok: false, error, throw: throwErr, else: elseDo, or, and };
}
exports.Err = Err;
//# sourceMappingURL=main.js.map