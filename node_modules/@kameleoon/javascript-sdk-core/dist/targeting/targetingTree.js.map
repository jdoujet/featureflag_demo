{"version":3,"file":"targetingTree.js","names":["TargetingTree","a","segment","c","_classCallCheck","_defineProperty","d","flattenSegment","nestedConditions","topLevelOperators","nestedNodes","map","conditions","operators","nodes","condition","TargetingNode","buildTree","tree","_createClass","key","value","evaluate","data","result","evaluateNode","error","Err","Ok","node","isLeafNode","type","KameleoonException","TargetingCondition","ok","inverse","isNonLeafNode","Operator","And","left","right","Or","length","_createForOfIteratorHelper","s","n","done","operator","shift","newNode","unshift","e","f","b","conditionsData","firstLevel","firstLevelOrOperators","forEach","conditionList","orOperators","group","convertOperators","push","exports"],"sources":["../../src/targeting/targetingTree.ts"],"sourcesContent":["import { Result, Ok, Err } from 'ts-res';\nimport { KameleoonError, KameleoonException } from 'src/kameleoonError';\nimport { ITargetingNode, TargetingNode } from './targetingNode';\nimport {\n  EvaluationDataType,\n  GroupedSegmentsType,\n  LeafNodeType,\n  NestedConditionGroupType,\n  NonLeafNodeType,\n  Operator,\n  SegmentType,\n} from './types';\n\ninterface ITargetingTree {\n  evaluate: (data: EvaluationDataType) => Result<boolean, KameleoonError>;\n}\n\nexport class TargetingTree implements ITargetingTree {\n  private tree: TargetingNode;\n  private error: KameleoonError | null = null;\n\n  constructor(segment: SegmentType) {\n    const { nestedConditions, topLevelOperators } =\n      this.flattenSegment(segment);\n\n    // --- Note ---\n    // - Targeting tree is built bottom-up, it's the only way to both get the consistent logic\n    // (grouping nested conditions) and have human readable tree representation.\n    // - Here is an example of how tree is built (we use strict complete binary tree)\n    // Let's say we have such a condition `value < 10 || value > 20 && value < 30`\n    // Following is pseudo code for building tree:\n    //\n    // `const operators = [Operator.Or, Operator.And]`\n    // `const conditions = [\n    //     {type: Condition.Less, value: 10},\n    //     {type: Condition.Greater, value: 20},\n    //     {type: Condition.Less, value: 30},\n    // ]`\n    //\n    // After the first iteration we have node like this:\n    //    AND\n    //   /   \\\n    //  <30  >20\n    //\n    // After the second iteration tree looks as follows:\n    //         OR\n    //        /  \\\n    //    AND    <10\n    //   /   \\\n    //  <30  >20\n    //\n    // As you can see Leaf Nodes contain conditions and Non-Leaf Nodes contain logical operators\n    const nestedNodes = nestedConditions.map(({ conditions, operators }) => {\n      const nodes = conditions.map((condition) => new TargetingNode(condition));\n\n      return this.buildTree(nodes, operators);\n    });\n\n    this.tree = this.buildTree(nestedNodes, topLevelOperators);\n  }\n\n  public evaluate(data: EvaluationDataType): Result<boolean, KameleoonError> {\n    const result = this.evaluateNode(this.tree, data);\n\n    if (this.error) {\n      return Err(this.error);\n    }\n\n    return Ok(result);\n  }\n\n  private evaluateNode(node: TargetingNode, data: EvaluationDataType): boolean {\n    if (this.isLeafNode(node)) {\n      if (node.error) {\n        // --- Note ---\n        // Non-existing condition should not break targeting tree\n        // instead it should be treated as `true` condition\n        if (node.error.type === KameleoonException.TargetingCondition) {\n          return true;\n        }\n\n        return false;\n      }\n\n      const result = node.value.evaluate(data);\n\n      if (!result.ok) {\n        this.error = result.error;\n\n        return false;\n      }\n\n      return node.inverse ? !result.data : result.data;\n    }\n\n    if (this.isNonLeafNode(node)) {\n      switch (node.value) {\n        case Operator.And: {\n          return (\n            this.evaluateNode(node.left, data) &&\n            this.evaluateNode(node.right, data)\n          );\n        }\n        case Operator.Or: {\n          return (\n            this.evaluateNode(node.left, data) ||\n            this.evaluateNode(node.right, data)\n          );\n        }\n        default:\n          break;\n      }\n    }\n\n    return false;\n  }\n\n  private isLeafNode(node: ITargetingNode): node is LeafNodeType {\n    return !Boolean(node.left && node.right);\n  }\n\n  private isNonLeafNode(node: ITargetingNode): node is NonLeafNodeType {\n    return Boolean(\n      node.left &&\n        node.right &&\n        (node.value === Operator.Or || node.value === Operator.And),\n    );\n  }\n\n  // --- Note ---\n  // This method mutates `nodes` array\n  // It's done for the sake of performance\n  private buildTree(\n    nodes: TargetingNode[],\n    operators: Operator[],\n  ): TargetingNode {\n    if (nodes.length === 1) {\n      return nodes[0];\n    }\n\n    for (const operator of operators) {\n      const left = nodes.shift();\n      const right = nodes.shift();\n\n      const newNode = new TargetingNode(operator, left, right);\n      nodes.unshift(newNode);\n    }\n\n    return nodes[0];\n  }\n\n  private flattenSegment(segment: SegmentType): GroupedSegmentsType {\n    const { firstLevel: conditions, firstLevelOrOperators: operators } =\n      segment.conditionsData;\n\n    const nestedConditions: NestedConditionGroupType[] = [];\n\n    conditions.forEach((condition) => {\n      const { conditions: conditionList, orOperators } = condition;\n\n      const group = {\n        operators: this.convertOperators(orOperators),\n        conditions: conditionList,\n      };\n\n      nestedConditions.push(group);\n    });\n\n    return {\n      topLevelOperators: this.convertOperators(operators),\n      nestedConditions,\n    };\n  }\n\n  private convertOperators(operators: boolean[]): Operator[] {\n    return operators.map((operator) => (operator ? Operator.Or : Operator.And));\n  }\n}\n"],"mappings":"0mFAiBa,CAAAA,aAAa,yBAIxB,SAAAC,EAAYC,CAAoB,CAAE,KAAAC,CAAA,MAAAC,eAAA,MAAAH,CAAA,EAAAI,eAAA,qBAAAA,eAAA,cAFK,IAAI,MAAAC,CAAA,CAIvC,IAAI,CAACC,cAAc,CAACL,CAAO,CAAC,CADtBM,CAAgB,CAAAF,CAAA,CAAhBE,gBAAgB,CAAEC,CAAiB,CAAAH,CAAA,CAAjBG,iBAAiB,CA8BrCC,CAAW,CAAGF,CAAgB,CAACG,GAAG,CAAC,SAAAV,CAAA,CAA+B,IAA5B,CAAAW,CAAU,CAAAX,CAAA,CAAVW,UAAU,CAAEC,CAAS,CAAAZ,CAAA,CAATY,SAAS,CACzDC,CAAK,CAAGF,CAAU,CAACD,GAAG,CAAC,SAACI,CAAS,QAAK,IAAI,CAAAC,4BAAa,CAACD,CAAS,CAAC,EAAC,CAEzE,MAAO,CAAAZ,CAAI,CAACc,SAAS,CAACH,CAAK,CAAED,CAAS,CACxC,CAAC,CAAC,CA/BF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA,IAAI,CAACK,IAAI,CAAG,IAAI,CAACD,SAAS,CAACP,CAAW,CAAED,CAAiB,CAC3D,CAAC,OAAAU,YAAA,CAAAlB,CAAA,GAAAmB,GAAA,YAAAC,KAAA,CAED,SAAAC,SAAgBC,CAAwB,CAAmC,CACzE,GAAM,CAAAC,CAAM,CAAG,IAAI,CAACC,YAAY,CAAC,IAAI,CAACP,IAAI,CAAEK,CAAI,CAAC,CAAC,MAE9C,KAAI,CAACG,KAAK,CACL,GAAAC,UAAG,EAAC,IAAI,CAACD,KAAK,CAAC,CAGjB,GAAAE,SAAE,EAACJ,CAAM,CAClB,CAAC,GAAAJ,GAAA,gBAAAC,KAAA,CAED,SAAAI,aAAqBI,CAAmB,CAAEN,CAAwB,CAAW,CAC3E,GAAI,IAAI,CAACO,UAAU,CAACD,CAAI,CAAC,CAAE,CACzB,GAAIA,CAAI,CAACH,KAAK,CACZ;AACA;AACA;AAAA,MACI,CAAAG,CAAI,CAACH,KAAK,CAACK,IAAI,GAAKC,kCAAkB,CAACC,kBAAkB,CAO/D,GAAM,CAAAT,CAAM,CAAGK,CAAI,CAACR,KAAK,CAACC,QAAQ,CAACC,CAAI,CAAC,CAAC,MAEpC,CAAAC,CAAM,CAACU,EAAE,CAMPL,CAAI,CAACM,OAAO,CAAG,CAACX,CAAM,CAACD,IAAI,CAAGC,CAAM,CAACD,IAAI,EAL9C,IAAI,CAACG,KAAK,CAAGF,CAAM,CAACE,KAAK,IAM7B,CAEA,GAAI,IAAI,CAACU,aAAa,CAACP,CAAI,CAAC,CAC1B,OAAQA,CAAI,CAACR,KAAK,EAChB,IAAK,CAAAgB,eAAQ,CAACC,GAAG,CACf,MACE,KAAI,CAACb,YAAY,CAACI,CAAI,CAACU,IAAI,CAAEhB,CAAI,CAAC,EAClC,IAAI,CAACE,YAAY,CAACI,CAAI,CAACW,KAAK,CAAEjB,CAAI,CAAC,CAGvC,IAAK,CAAAc,eAAQ,CAACI,EAAE,CACd,MACE,KAAI,CAAChB,YAAY,CAACI,CAAI,CAACU,IAAI,CAAEhB,CAAI,CAAC,EAClC,IAAI,CAACE,YAAY,CAACI,CAAI,CAACW,KAAK,CAAEjB,CAAI,CAAC,CAGvC,QACQ,CAIZ,QACF,CAAC,GAAAH,GAAA,cAAAC,KAAA,CAED,SAAAS,WAAmBD,CAAoB,CAAwB,CAC7D,MAAO,IAASA,CAAI,CAACU,IAAI,EAAIV,CAAI,CAACW,KAAK,CACzC,CAAC,GAAApB,GAAA,iBAAAC,KAAA,CAED,SAAAe,cAAsBP,CAAoB,CAA2B,CACnE,SACEA,CAAI,CAACU,IAAI,EACPV,CAAI,CAACW,KAAK,GACTX,CAAI,CAACR,KAAK,GAAKgB,eAAQ,CAACI,EAAE,EAAIZ,CAAI,CAACR,KAAK,GAAKgB,eAAQ,CAACC,GAAG,CAAC,CAEjE,CAEA;AACA;AACA;AAAA,GAAAlB,GAAA,aAAAC,KAAA,CACA,SAAAJ,UACEH,CAAsB,CACtBD,CAAqB,CACN,CACf,GAAqB,CAAC,GAAlBC,CAAK,CAAC4B,MAAY,CACpB,MAAO,CAAA5B,CAAK,CAAC,CAAC,CAAC,CAChB,IAAAX,CAAA,CAAAG,CAAA,CAAAqC,0BAAA,CAEsB9B,CAAS,MAAhC,IAAAP,CAAA,CAAAsC,CAAA,KAAAzC,CAAA,CAAAG,CAAA,CAAAuC,CAAA,IAAAC,IAAA,EAAkC,IAAvB,CAAAC,CAAQ,CAAA5C,CAAA,CAAAkB,KAAA,CACXkB,CAAI,CAAGzB,CAAK,CAACkC,KAAK,EAAE,CACpBR,CAAK,CAAG1B,CAAK,CAACkC,KAAK,EAAE,CAErBC,CAAO,CAAG,GAAI,CAAAjC,4BAAa,CAAC+B,CAAQ,CAAER,CAAI,CAAEC,CAAK,CAAC,CACxD1B,CAAK,CAACoC,OAAO,CAACD,CAAO,CACvB,CAAC,OAAAhD,CAAA,EAAAK,CAAA,CAAA6C,CAAA,CAAAlD,CAAA,UAAAK,CAAA,CAAA8C,CAAA,GAED,MAAO,CAAAtC,CAAK,CAAC,CAAC,CAChB,CAAC,GAAAM,GAAA,kBAAAC,KAAA,CAED,SAAAd,eAAuBL,CAAoB,CAAuB,KAAAmD,CAAA,MAAAlD,CAAA,CAE9DD,CAAO,CAACoD,cAAc,CADJ1C,CAAU,CAAAT,CAAA,CAAtBoD,UAAU,CAAqC1C,CAAS,CAAAV,CAAA,CAAhCqD,qBAAqB,CAG/ChD,CAA4C,CAAG,EAAE,CAavD,MAXA,CAAAI,CAAU,CAAC6C,OAAO,CAAC,SAAC1C,CAAS,CAAK,IACZ,CAAA2C,CAAa,CAAkB3C,CAAS,CAApDH,UAAU,CAAiB+C,CAAW,CAAK5C,CAAS,CAAzB4C,WAAW,CAExCC,CAAK,CAAG,CACZ/C,SAAS,CAAEwC,CAAI,CAACQ,gBAAgB,CAACF,CAAW,CAAC,CAC7C/C,UAAU,CAAE8C,CACd,CAAC,CAEDlD,CAAgB,CAACsD,IAAI,CAACF,CAAK,CAC7B,CAAC,CAAC,CAEK,CACLnD,iBAAiB,CAAE,IAAI,CAACoD,gBAAgB,CAAChD,CAAS,CAAC,CACnDL,gBAAgB,CAAhBA,CACF,CACF,CAAC,GAAAY,GAAA,oBAAAC,KAAA,CAED,SAAAwC,iBAAyBhD,CAAoB,CAAc,CACzD,MAAO,CAAAA,CAAS,CAACF,GAAG,CAAC,SAACoC,CAAQ,QAAM,CAAAA,CAAQ,CAAGV,eAAQ,CAACI,EAAE,CAAGJ,eAAQ,CAACC,GAAG,CAAC,CAC5E,CAAC,IAAArC,CAAA,IAAA8D,OAAA,CAAA/D,aAAA,CAAAA,aAAA"}