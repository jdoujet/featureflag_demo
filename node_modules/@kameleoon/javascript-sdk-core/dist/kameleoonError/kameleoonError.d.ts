import { KameleoonStorageKey } from '../storage';
import { TargetingType } from '../targeting';
import { KameleoonException } from './types';
/**
 * @class
 * KameleoonError - extends standard `Error` by adding custom `type` property with the type of `KameleoonException`
 * */
export declare class KameleoonError extends Error {
    private errorType;
    /**
     * @param {KameleoonException} type - type of KameleoonError represented by `KameleoonException` enum
     * */
    constructor(type: KameleoonException.Initialization | KameleoonException.ClientConfiguration | KameleoonException.VisitorCodeMaxLength | KameleoonException.VisitorCodeEmpty | KameleoonException.StorageInitialization | KameleoonException.EventSourceInitialization | KameleoonException.VariationNotFound | KameleoonException.RemoteData | KameleoonException.MaximumRetriesReached);
    constructor(type: KameleoonException.FeatureFlagConfigurationNotFound, featureKey: string, visitorCode: string);
    constructor(type: KameleoonException.FeatureFlagVariableNotFound, variableKey: string, visitorCode: string);
    constructor(type: KameleoonException.NotTargeted | KameleoonException.NotAllocated, visitorCode: string);
    constructor(type: KameleoonException.ExperimentConfigurationNotFound, experimentId: number, visitorCode: string);
    constructor(type: KameleoonException.StorageWrite | KameleoonException.JSONParse, err: unknown);
    constructor(type: KameleoonException.StorageRead, storageKey: string);
    constructor(type: KameleoonException.StorageParse, err: unknown, key: KameleoonStorageKey);
    constructor(type: KameleoonException.TargetingCondition, targetingType: TargetingType);
    constructor(type: KameleoonException.AmongValuesCheck, err: unknown, value: string);
    constructor(type: KameleoonException.NumberParse | KameleoonException.VersionParse | KameleoonException.SemanticVersionParse, value: string);
    get type(): KameleoonException;
}
