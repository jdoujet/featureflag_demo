import { Result } from 'ts-res';
import { KameleoonError } from '../kameleoonError/kameleoonError';
import { CustomData, KameleoonDataType } from '../kameleoonData';
import { SegmentType, TargetingDataType, TargetingTree } from '../targeting';
import { CampaignConfigurationParametersType, ConfigurationType, ExperimentItemType, FeatureFlagType, UnsentTargetingDataType } from './types';
interface ICampaignConfiguration {
    initialize: (useCache?: boolean) => Promise<Result<void, KameleoonError>>;
    addTargetingData: (visitorCode: string, ...data: KameleoonDataType[]) => Result<void, KameleoonError>;
    getUnsentData: (visitorCode: string) => UnsentTargetingDataType[string] | undefined;
    clearUnsentData: (visitorCode: string) => void;
    isPersistentCustomData: (dataItem: KameleoonDataType) => boolean;
    onConfigurationUpdate: (callback: () => void) => void;
    readonly experiments: ExperimentItemType[];
    readonly storedTargetingData: TargetingDataType;
    readonly featureFlags: FeatureFlagType[];
    readonly configuration: ConfigurationType;
    readonly unsentDataVisitors: string[];
}
export declare class CampaignConfiguration implements ICampaignConfiguration {
    private configurationUpdateCallback?;
    private updateConfigurationIntervalId;
    private updateType;
    private targetingDataIntervalId;
    private unsentTargetingData;
    private targetingData;
    private targetingTrees;
    private configurationData;
    private settings;
    private lastUpdate;
    private storage;
    private offlineTrackingStorage;
    private requester;
    private eventSource?;
    private externalEventSource;
    private externalClientConfiguration?;
    private targetingDataLifetime;
    private localCustomDataIndexes;
    private persistentCustomDataIndexes;
    constructor({ settings, storage, requester, externalClientConfiguration, targetingCleanupInterval, offlineTrackingStorage, externalEventSource, }: CampaignConfigurationParametersType);
    initialize(useCache?: boolean): Promise<Result<void, KameleoonError>>;
    private cleanupHandlers;
    private handleExternalUpdates;
    private handleRealTimeUpdates;
    private handlePollingUpdates;
    addTargetingData(visitorCode: string, ...data: KameleoonDataType[]): Result<void, KameleoonError>;
    getUnsentData(visitorCode: string): UnsentTargetingDataType[string] | undefined;
    clearUnsentData(visitorCode: string): void;
    getTargetingTree(segment: SegmentType): TargetingTree;
    onConfigurationUpdate(callback: () => void): void;
    isPersistentCustomData(dataItem: KameleoonDataType): dataItem is CustomData;
    get unsentDataVisitors(): string[];
    get storedTargetingData(): TargetingDataType;
    get experiments(): ExperimentItemType[];
    get featureFlags(): FeatureFlagType[];
    get configuration(): ConfigurationType;
    private checkShouldUpdate;
    private cleanupOutdatedTargetingData;
    private readStorageData;
    private clearTargetingTrees;
    /**
     * Updates client configuration
     *
     * @param useCache - if true, will not update configuration if it is already present (for _offline_ mode)
     * @param timeStamp - timestamp for real-time configuration update
     *
     * @returns `true` if current update type should be toggled (SSE/Polling)
     */
    private updateClientConfiguration;
    private updateStorageData;
}
export {};
